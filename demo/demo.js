// Generated by CoffeeScript 1.8.0
(function() {
  var diagonal, h, i, m, mergeTrees, pushPending, root, tree, vis, w;

  tree = null;

  vis = null;

  m = [20, 120, 20, 120];

  w = window.innerWidth - m[1] - m[3];

  h = window.innerHeight - m[0] - m[2];

  i = 0;

  root = null;

  diagonal = d3.svg.diagonal().projection(function(d) {
    return [d.y, d.x];
  });

  window.initTree = function() {
    tree = d3.layout.tree().size([h, w]);
    return vis = d3.select("#body").append("svg:svg").attr("width", w + m[1] + m[3]).attr("height", h + m[0] + m[2]).append("svg:g").attr("transform", "translate(" + m[3] + "," + m[0] + ")");
  };

  window.loadTree = function(json) {
    root = json;
    root.x0 = h / 2;
    root.y0 = 0;
    return updateTree(root);
  };

  window.updateJson = function(x) {
    if (root.name !== x.name) {
      return loadTree(x);
    } else {
      root = mergeTrees(root, x);
      return updateTree(null);
    }
  };

  pushPending = function(node, x, y) {
    var n, _i, _len, _ref, _results;
    console.log("Pushing from " + node.name);
    node.sourceX = x;
    node.sourceY = y;
    if (node.children != null) {
      _ref = node.children;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        _results.push(pushPending(n));
      }
      return _results;
    }
  };

  mergeTrees = function(old, received) {
    var mergeChildren;
    if (old.name !== received.name) {
      old.name = received.name;
    }
    mergeChildren = function(children) {
      var x, y;
      children = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = children.length; _i < _len; _i++) {
          x = children[_i];
          _results.push((function(x) {
            var idx, y;
            idx = ((function() {
              var _j, _len1, _ref, _results1;
              _ref = received.children;
              _results1 = [];
              for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
                y = _ref[_j];
                _results1.push(y.name);
              }
              return _results1;
            })()).indexOf(x.name);
            if (idx >= 0) {
              return mergeTrees(x, received.children.splice(idx, 1)[0]);
            } else {
              return null;
            }
          })(x));
        }
        return _results;
      })();
      children = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = children.length; _i < _len; _i++) {
          y = children[_i];
          if (y != null) {
            _results.push(y);
          }
        }
        return _results;
      })();
      if ((received.children != null) && received.children.length > 0) {
        console.log("" + received.children.length + " new kids @ " + old.name);
        pushPending(old, old.x0, old.y0);
        children = children.concat(received.children);
      }
      return children;
    };
    if ((received.children != null)) {
      if ((old._children != null)) {
        old._children = mergeChildren(old._children);
      } else {
        if (old.children) {
          old.children = mergeChildren(old.children);
        } else {
          pushPending(old, old.x0, old.y0);
          old._children = received.children;
        }
      }
    } else {
      if ((old.children != null) || (old._children != null)) {
        pushPending(old, old.x0, old.y0);
        if (old.children != null) {
          delete old.children;
        }
        if (old._children != null) {
          delete old._children;
        }
      }
    }
    return old;
  };

  window.updateTree = function(source) {
    var duration, link, node, nodeEnter, nodeExit, nodeUpdate, nodes;
    duration = 500;
    nodes = tree.nodes(root).reverse();
    node = vis.selectAll("g.node").data(nodes, function(d) {
      return d.id || (d.id = ++i);
    });
    nodeEnter = node.enter().append("svg:g").attr("class", "node").attr("transform", source ? (function(d) {
      return "translate(" + source.y0 + "," + source.x0 + ")";
    }) : (function(d) {
      return "translate(" + d.sourceY + "," + d.sourceX + ")";
    })).on("click", function(d) {
      toggleTreeNode(d);
      return updateTree(d);
    });
    nodeEnter.append("svg:circle").attr("r", 1e-6).style("fill", function(d) {
      if (d._children) {
        return "lightsteelblue";
      } else {
        return "#fff";
      }
    });
    nodeEnter.append("svg:text").attr("x", function(d) {
      if (d.children || d._children) {
        return -10;
      } else {
        return 10;
      }
    }).attr("dy", ".35em").attr("text-anchor", function(d) {
      if (d.children || d._children) {
        return "end";
      } else {
        return "start";
      }
    }).text(function(d) {
      return d.name;
    }).style("fill-opacity", 1e-6);
    nodeUpdate = node.transition().duration(duration).attr("transform", function(d) {
      return "translate(" + d.y + "," + d.x + ")";
    });
    nodeUpdate.select("circle").attr("r", 4.5).style("fill", function(d) {
      if (d._children) {
        return "lightsteelblue";
      } else {
        return "#fff";
      }
    });
    nodeUpdate.select("text").style("fill-opacity", 1);
    nodeExit = node.exit().transition().duration(duration).attr("transform", source ? (function(d) {
      return "translate(" + source.y + "," + source.x + ")";
    }) : (function(d) {
      return "translate(" + d.sourceY + "," + d.sourceX + ")";
    })).remove();
    nodeExit.select("circle").attr("r", 1e-6);
    nodeExit.select("text").style("fill-opacity", 1e-6);
    link = vis.selectAll("path.link").data(tree.links(nodes), function(d) {
      return d.target.id;
    });
    link.enter().insert("svg:path", "g").attr("class", "link").attr("d", source != null ? function(d) {
      var o;
      o = {
        x: source.x0,
        y: source.y0
      };
      return diagonal({
        source: o,
        target: o
      });
    } : function(d) {
      var o;
      o = {
        x: d.sourceX,
        y: d.sourceY
      };
      return diagonal({
        source: o,
        target: o
      });
    }).transition().duration(duration).attr("d", diagonal);
    link.transition().duration(duration).attr("d", diagonal);
    link.exit().transition().duration(duration).attr("d", source != null ? function(d) {
      var o;
      o = {
        x: source.x0,
        y: source.y0
      };
      return diagonal({
        source: o,
        target: o
      });
    } : function(d) {
      var o;
      o = {
        x: d.sourceX,
        y: d.sourceY
      };
      return diagonal({
        source: o,
        target: o
      });
    }).remove();
    return nodes.forEach(function(d) {
      d.x0 = d.x;
      return d.y0 = d.y;
    });
  };

  window.toggleTreeNode = function(d) {
    if (d.children) {
      d._children = d.children;
      return d.children = null;
    } else {
      d.children = d._children;
      return d._children = null;
    }
  };

  window.refreshTree = function(url) {
    return d3.json(url, function(err, json) {
      return loadTree(json);
    });
  };

}).call(this);
